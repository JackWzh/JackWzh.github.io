---
layout: post
categories: blog
share: true
comments: true
title: '基于FitNesse（FitSharp）的Prism MVVM 集成测试'
date: '2018-1-14T0:30:00'
modified: '2018-1-14T0:30:00'
tags: [Blog, C#, Prism 5.0, MVVM, Integration Test]
author: Old Jack
hidelogo: false
image:
    feature: LIS/1.jpg
---
折腾了这么久，终于在2号调通了第一个基于 FitNesse 的测试用例，交给集成组了。这一路上看了一些书和文档，踩了不少的坑，遇到了很多莫名其妙的bug，调试 FitNesse 也很麻烦，所以大部分时候都是一个黑箱系统；调试测试用例也很痛苦，再加上我们生产环境太过恶劣，导致整个过程持续了很长的时间。现在回头看看呢，其实也没什么难点......但不管怎么说，整个过程中确实学到了一些东西，趁现在有空，总结一下吧。

<div class="text-divider"></div>

# UI, Presentation, Bussiness Logic 的分离

这个是 MVVM 模式的一个核心点所在，UI Logic、Presentation Logic、Bussiness Logic 的分离也是整个 WPF-Prism 项目可测试的基础（单元测试&集成测试），所以在设计和实现 Prism 项目时，一定要尽可能地去将这三个 Logic 分开。而对于包含 UI 的集成测试而言，最重要的是 UI Logic 与另外两者的分离。

UI 元素和 Logic 在整个开发流程中改变的可能性远高于 Presentation Logic 和 Bussiness Logic，因此集成测试时理应彻底抛弃 UI 层，主要关注模块组合起来后 Bussiness Logic 的正确性，以及 Presentation Logic 的正确性。不过这里有一个问题，在应用中经常会有一些事件发布订阅，这个时候会在 Prism 的 Rigion 中注册 View，然后刷新 Region 来展示 View，而 View Model 是 View 的 DataContext，没有 View 也就没有它背后的 View Model，也就无法测试后面的 Presentation Logic 和 Bussiness Logic。这就不可避免地还是需要 View 的实例存在。

为了解决这个问题有两种方案：

1. 抽取模块中的事件发布订阅代码，放入测试代码中；
2. 直接从 RegionManager 中获取 View，获取其 DataContext 后利用反射调用数据绑定的 ICommand Interface 实现。


目前我采用的还是第一种方法，这是因为整个集成测试流程还在 prototype 阶段，所以第一目的是找到一种方法让可以打穿整个流程。虽然手动抽取代码会带来额外的工作量，同时也无法保证时间发布订阅的逻辑是否和源应用一致，甚至可能会出现有些缺陷无法被测试出来的问题。但是基本的业务逻辑可以在短时间内得以复现，不需要复杂的结构，直接调用 View Model 的 ICommand 即可。另外，这种方法可以彻底抛弃 UI Logic 对业务功能进行测试，符合我们一开始对集成测试的预期。

第二种方法无疑可以直接保证整个应用的逻辑完整，不过这也意味着可能会因为 View 相关的错误/缺陷而导致测试用例无法通过的可能性。

以后具体应该使用何种方法，我现在还没有一个定论，因为这取决于我们的测试代码是由谁来编写。如果是由集成组来编写，毫无疑问第一种方法并不是很友好，毕竟他们还要鉴别哪些代码是有用的，哪些是无用的，第二种方法只需要告诉他们需要到哪里去找 View，然后调用什么 View Model 的什么 ICommand，该检测 View Model 的哪个 Property 就可以编写测试用例代码了。

如果是由开发人员编写集成测试代码，那么显然第一种方法可以快速实现干净的 Bussiness Logic 和 Presentaion Logic 测试，而且完全无需等待 View 是否写好即可进行集成测试（不过其实我们根本就没有专业的UI设计人员，所以UI基本也是开发人员自己琢磨自己写的，大都是先有 View 才有 View Model，23333，以后应该会有所改观吧）。

我知道，一个成熟的 WPF 开发团队，成熟的软件开发团队这些职责应该早就分配好了，然而条件有限，所以，这也没有办法。

<div class="text-divider"></div>

# 测试用例的结构和解析

在整个调研的过程中，我发现这个问题是如何打通整个集成测试流程之后最关键的问题。在一开始的阶段我也找过 WPF 集成测试的框架和工具，然而并没有什么特别好的解决方案，有针对 UI 元素的集成测试框架，但是这不是我们所想要的，所以就没有采用那个框架（后来集成组推荐的 FitNesse 框架是一个通用集成测试框架，头脑思路放宽之后其可能就会有解决方案）。

在这个背景下，于是我自行设计了一套测试用例的结构，并通过反射构造了一个将测试用例内容映射到具体 View Model 及其 Member 的“解释器”。输入采用.xml文件，每个测试用例是一个流结构，流中会包含 View Model 的具体名称，调用的具体方法，以及应该响应哪些事件，检测哪些 Property，然后会根据流中的顺序依次执行 View Model 初始化、调用 ICommand，响应事件，检测 Property。

然而在我已经完成了80%的工作后，集成组来找到我看我这里有什么进展。我发现他们用的测试用例是.xlsx文件，因为以前没有自动化测试，使用手动测试，对着测试用例一个一个测，一个一个对照结果，因此测试用例是.xlsx文件。

于是我开始重新审视这个架构，发现.xml测试用例的逻辑结构不但略显复杂，而且需要知道很多代码的细节才能顺利编写测试用例（这还是在“解析器”已经简化了很多工作的情况下，不过后来使用 FitNesse 时发现还是需要直到很多细节才行，23333）。然而已然是这个架构了，要是重构的话，整个流程可能都要重新设计，所以我只好开始编写.xlsx到.xml的转换程序。

就在这之后不久，我去找集成组告诉他们已经实现了集成测试类库/命令行程序（这个内容会在下一小节讲讲述），他们提出他们准备使用 FitNesse 框架来进行集成测试，给我演示了一些非常基本的用法，这让我对 FitNesse 产生了兴趣。通过阅读文档、查阅技术贴并亲身实践后，我发现 FitNesse 就是我们所寻找的“解释器”！于是就彻底开始采用 FitNesse 框架。

现在看来，集成测试其实和编译器是有相似之处的，都有前端和后端，编译器前端经过词法分析、语法分析等步骤理清代码结构检查语法错误，测试用例也需要实现定义好结构并被“解析器”解析检查是否有错误；编译器后面会将前端处理好的结构转换成更底层的代码（编译原理除了正则表达式，其余的基本都还给老师了，当然我们专业讲得确实不深，而我也没有深入地研究），测试用例的“解析器”也会根据解析的结果调用实际应用中的命令/逻辑。整个这样的一个集成测试框架其实也可以看作一种编译器吧。

了解了 FitNesse 后，就对 Uncle Bob 的崇敬有多了几分，也越发觉得软件开发流程真的是很重要，再怎么强大的技术，在一个简陋不完善的软件开发流程中也很难快速地发挥其能力，甚至无法发力。

<div class="text-divider"></div>

# 集成测试的运行与结果检测

这还要从最开始的调研讲起。一开始给我和另一个同事安排这个任务时，我们都是懵逼的，因为谁也没做过这样的东西，简直是毫无头绪。经过一段时间的调研和实践，我们成功地把集成测试功能作为一个 Module（Prism 框架开年）加入到了应用中，然而这意味着运行集成测试是必须要启动我们的客户端程序，同时这也很难与 Jenkins 集成到一起。

于是我开始重新研究整个 Prism 框架，开始考虑制作一个类库或者命令行程序，使其他应用能通过 API 感知到测试用例是否通过。在我实现了70%左右时，我告诉集成组已经接近成形了，然后他们告诉我发现了 FitNesse 这个框架，完美解决了与持续集成框架集成等众多问题。

我自然是很高兴的，然而随着编写 prototype 的深入，我发现了几个问题：

1. Prism 的 EventAggregator 必须运行在一个UI 线程中，而 FitNesse 框架 Runner 的 Main 方法并不是一个 STA（single thread apartment） 方法；
2. 可以创建一个新的线程，标记为 STA 的方式来模拟一个 UI 线程，然而这个内部线程不会自动结束，所以 Runner 也不会结束，所以 FitNesse 会被卡住；
3. 有了 UI 线程，那么就需要能够访问 UI 线程中的元素，这样才能进行集成测试，然而源应用是不会暴露出内部的成员的；
4. 在正常情况下我们可以直接看到界面来判断后台服务是否运行结束，检查结果是否正确，而现在无法知道后台运行何时结束，也就无法得知应该何时去检测结果，即使长时间计时然后检测的方式，又因为 UI 线程在运行计时方法，而无法更新 UI 元素，导致根本无法检测结果。

针对第一个和第二个问题，我新建了一个 WPF 程序，它的 StartUp 方法中实现了 Runner Main 方法的逻辑（就一行代码），这样就可以保证拥有一个 UI 线程，同时在测试用例运行结束后会退出 WPF应用。

针对第三个问题，采用了提取 Prism 源码的方式，将所需要的 UnityContainer、EventAggregator 等成员设为 static public，使得测试类可以直接调用它们，从而编写集成测试代码。

针对第四个问题，最后还是采用了长时间计时的方式，在计时的时候不断地强制更新 UI 元素（利用 Dispatcher 的一些黑科技），最后实现了检测结果。

<div class="text-divider"></div>

对 WPF 和 Prism 了解不深入，以及一开始并未找到 FitNesse 这样的框架，导致花了2个多月的时间才实现了一个 prototype，说实话这多少有点让人沮丧。而且现在回头看这一切，其实根本没什么难点，就那么回事儿呗。

当然了，借这个机会确实学到了很多东西：

- 学习了很多 C#、WPF、Prism、Design Pattern 的知识；
- 了解了集成测试应该是怎样的一个流程；
- 基本完全独立地设计了一个 Prism Module，虽然最后被弃用了，囧；
- 认识到了软件开发流程的重要性。

或许，也不算太失败吧......

最后，欢迎大家提出自己的观点和见解，如果您有更好的技术方案，那我更是希望能向您学习请教。晚安~